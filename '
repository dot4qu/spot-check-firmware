#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"

#include "driver/uart.h"

#include "log.h"

// Should match CLI_UART_TX_BYTES probably
#define LOG_OUT_BUFFER_BYTES (512)

static uart_handle_t    *console_handle;
static char             *log_out_buffer;
static SemaphoreHandle_t mutex_handle;
static StaticSemaphore_t mutex_buffer;

static const char *level_strs[] = {
    [LOG_LEVEL_ERROR] = "[ERR]",
    [LOG_LEVEL_INFO] = "[INF]",
    [LOG_LEVEL_DEBUG] = "[DBG]",
};

void log_init(uart_handle_t *console) {
    log_out_buffer = pvPortMalloc(LOG_OUT_BUFFER_BYTES * sizeof(uint8_t));

    mutex_handle = xSemaphoreCreateMutexStatic(&mutex_buffer);
    assert(mutex_handle);

    console_handle = console;
}

void log_log_line(char *tag, log_level_t level, char *fmt, ...) {
    BaseType_t rval = xSemaphoreTake(mutex_handle, pdMS_TO_TICKS(50));
    // TODO :: could handle this more elegantly
    assert(rval == pdTRUE);

    char *moving_log_out_buffer = log_out_buffer;
    char temp_tag[20];
    size_t temp_tag_size = sprintf(temp_tag, "[%s]", tag);
    snprintf(moving_log_out_buffer, temp_tag_size, "%.15s ", temp_tag);
    moving_log_out_buffer += temp_tag_size;

    char *level_str = level_strs[level];
    memcpy(moving_log_out_buffer, level_str, strlen(level_str));
    va_list args;
    va_start(args, fmt);
    size_t formatted_size = vsnprintf(log_out_buffer, LOG_OUT_BUFFER_BYTES, fmt, args);
    va_end(args);

    xSemaphoreGive(mutex_handle);

    // Let go of the mutex before sending to serial, it'll handle re-entrancy with it's own internal queueing
    // (maybe?)
    uart_write_bytes(console_handle->port, log_out_buffer, formatted_size);
}
